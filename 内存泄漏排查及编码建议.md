
内存泄漏排查及编码建议
=============



 



### 不要让长生命周期变量持有待回收对象的引用
## 编码原则
#### 1.	尽量使用Application的Context 而不是Activity的Context（比如Toast）。
Activity包含很多视图，视图含有图片文字等资源，很容易能出现内存泄露占用大量内存。

#### 2. 不要用static变量直接或间接持久引用大对象 Context、Activity、View、Dialog、Drawable等。
Static变量是类变量，不会随着对象的销毁而销毁，一旦持有对象，会一直在内存中不能释放。
	View、Dialog、Drawable 等会直接或间接持有Context、Activity的引用。Drawable绑定到View后会持有View的引用，进而持有Activity的引用。（4.0之后的版本Drawable引用问题修复）
#### 3.	尽量使用WeakReference 持有Context等引用。（具体参见弱引用使用方法）
#### 4.	尽量不要在Activity中使用非静态内部类，会持有外部类的引用。（容易忽视）
Handler、AsyncTask 以非静态内部类的方式实现容易内存泄露，所以尽量以单独的类文件或者静态内部类的形式实现，同时WeakReference 引用Activity。
```java
 public class MainActivity extends Activity {
    private static Handler mHandler = new Handler(){
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
}
```
mHandler 用static关键字 **（原则2）**非静态匿名内部类的形式实现，将会永久持有当前MainActivity实例。附Handler正确使用方式：
```java
public class MainActivity extends Activity {
    private static class MyHandler extends Handler {
        private WeakReference<Context> reference;
        public MyHandler(Context context) {
            reference = new WeakReference<Context>(context);
        }
        @Override
        public void handleMessage(Message msg) {
            Context context = reference.get();
        }
    }
    private Handler mHandler = new MyHandler(this);
    @Override
    protected void onDestroy() {
        super.onDestroy();
        mHandler.removeCallbacksAndMessages(null);
    }
}
```
 
#### 5.	占用资源的在使用完后应关闭
File，Cursor，Stream等等使用完应关闭
#### 6.	不要滥用static变量、单例
static变量的滥用在小微中尤甚。各种大型全局static List 从来不清空释放。U.java中的列表将会一直占用内存
 
#### 7.	各种注册有对应的反注册 （容易忽视）
* EventBus的 register 和 unregister
* BraodcastReceiver的 registerReceiver 和 unregisterReceiver

#### 8.	Bitmap使用后应调用recycle（android3.0之后已经解决）
#### 9.	ListView优化使用convertVi ew 和 ViewHolder
#### 10.	WebView坑很多
WebView还不完善加载大量视图时很容易内存泄露，且在不同版本不同机型上表现都不一致。目前比较好的做法是
加载WebView的界面开启新进程，在该页面退出之后关闭这个进程。
使用System.exit(0)直接退出虚拟机。
这样做需要解决新进程启动慢、进程间同步等问题。
